; C functions that are needed
let print		"print"
let println		"println"

let malloc		"malloc"
let free		"free"
let exit		"exit"

let fopen		"fopen"
let fclose		"fclose"
let fputc		"fputc"
let fputs		"fputs"
let fseek		"fseek"
let ftell		"ftell"
let fread		"fread"
let fgetc		"fgetc"

; constant strings
let format_char	"%c"
let format_int	"%d"
let format_hex	"%x"
let format_ptr	"%p"
let format_str	"%s"
let newline		"\n"
let tab			"\t"
let nullchar	"\0"
let kw_if		"if"
let	kw_while	"while"
let kw_for		"for"
let kw_func		"func"
let kw_do		"do"
let kw_return	"return"
let kw_continue	"continue"
let kw_break	"break"

jmp main

; args
; 0 -> pointer to string
strlen:
	iarg	0 ; string (0x00)
	ipush	0 ; length (0x01)
A00:
	; *string == 0
	ilload	0x00
	cder
	ipush	0
	icmp
	jnz		A01
	
	; string++
	ilload	0x00
	icinc	1
	ilsave	0x00
	
	; length++
	ilload	0x01
	icinc	1
	ilsave	0x01

	jmp		A00
A01:
	; return length
	ilload	0x01
	iret

; args
;	0 -> ptr to string
;	1 -> ptr to string
strcmp:
	iarg	0
	iarg	1
ZZ00:
	ilload	0x00
	cder
	ilload	0x01
	cder
	icmp
	jnz		ZZ01
	ipush	0
	iret
ZZ01:
	ilload	0x00
	cder
	jnz		ZZ02
	ipush	1
	iret
ZZ02:
	ilload	0x00
	icinc	1
	ilsave	0x00
	ilload	0x01
	icinc	1
	ilsave	0x01
	jmp		ZZ00

; args
;	0 -> destination
;	1 -> source
strcpy:
	iarg	0 ; s[0x00] = destination
	iarg	1 ; s[0x01] = source
Z00:
	; while (*s[0x01]);
	ilload	0x01
	cder
	jz		Z01
	
	; *s[0x01]+ = *s[0x00]+
	ilload	0x00
	ilload	0x01
	cder
	isave

	ilload	0x00
	icinc	1
	ilsave	0x00

	ilload	0x01
	icinc	1
	ilsave	0x01

	jmp		Z00
Z01:
	vret

; args
;	0 -> char n
isdigit:
	iarg	0
	ipush	'0'
	ige
	iarg	0
	ipush	'9'
	ile
	land
	iret

; args
;	0 -> char n
isalpha:
	iarg	0
	ipush	'a'
	ige
	iarg	0
	ipush	'z'
	ile
	land
	iarg	0
	ipush	'A'
	ige
	iarg	0
	ipush	'Z'
	ile
	land
	lor
	iret

; args
;	0 -> char n
isalnum:
	iarg	0
	call	isalpha, 1
	iarg	0
	call	isdigit, 1
	lor
	iret

; args
;	0 -> char n
ispunct:
	; return (
	;	(n >= '!' && n <= '/') ||
	;	(n >= ':' && n <= '@') ||
	;	(n >= '[' && n <= '\'') ||
	;	(n >= '{' && n <= '~')
	; );
	iarg	0
	ipush	'!'
	ige
	iarg	0
	ipush	'/'
	ile
	land
	iarg	0
	ipush	':'
	ige
	iarg	0
	ipush	'@'
	ile
	land
	lor
	iarg	0
	ipush	'['
	ige
	iarg	0
	ipush	96
	ile
	land
	lor
	iarg	0
	ipush	'{'
	ige
	iarg	0
	ipush	'~'
	ile
	land
	lor
	iret

; token format
;	0 -> type
;	1 -> word
;	2 -> next

; args
;	0 -> type
;	1 -> word
__Token_new:
	ipush	0 ; 0x00 -> token storage

	; token = malloc(24);
	ipush	24
	ccall	malloc
	ilsave	0x00
	
	; token->type = args[0x00]
	ilload	0x00
	ipush	0
	padd
	iarg	0
	isave

	; token->word = malloc(strlen(args[1]) + 1);
	ilload	0x00
	ipush	1
	padd
	iarg	1
	call	strlen, 1
	ipush	1
	iadd
	ccall	malloc
	isave

	; strcpy(token->word, args[1]);
	iarg	1
	ilload	0x00
	ipush	1
	padd
	ider
	call	strcpy, 2
	
	; token->next = NULL;
	ilload	0x00
	ipush	2
	padd	
	ipush	0
	isave

	; return token;
	ilload	0x00
	iret

; args
;	0 -> Token**	head
;	1 -> int		type
;	2 -> char*		word

__Token_append:
	res		3

	; s[0x00] = arg0 (token)
	iarg	0
	ilsave	0x00

	; s[0x01] = __Token_new(arg[1], arg[2]);
	iarg	2
	iarg	1
	call	__Token_new, 2
	ilsave	0x01

	; s[0x02] = *token
	iarg	0
	ider
	ilsave	0x02
	
	ilload	0x02	
	jz		C01
C00: ; *head != NULL
C00_00:
	; while ((*token)->next);
	ilload	0x02
	ipush	2
	padd
	ider
	jz		C00_01
	
	; (*token) = (*token)->next;	
	ilload	0x02
	ilload	0x02
	ipush	2
	padd
	ider
	ilsave	0x02

	jmp		C00_00
C00_01:
	; (*token)->next = s[0x01]
	ilload	0x02
	ipush	2
	padd	
	ilload	0x01
	isave

	jmp		C02
C01: ; *head == NULL
	; *head = s[0x00]	
	ilload	0x00
	ilload	0x01
	isave
C02:
	vret

__Token_print:
	iarg	0
D00:
	ilload	0x00
	jz		D01
	
	let token_format_str "TOKEN (word '%s' | type %d)"
	ilload	0x00
	ider
	ilload	0x00
	ipush	1
	padd
	ider
	ipush	token_format_str
	ccall	println

	ilload	0x00
	ipush	2
	padd
	ider
	ilsave	0x00

	jmp		D00
D01:
	vret	

; args:
;	0 -> nargs (can ignore)
;	1 -> input file name
main:
	res		0x100

	; stack map
	;	0x00 input file name
	;	0x01 input file handle
	;	0x02 input file contents
	;	0x03 input file contents length
	;	0x04 current character
	;	0x05 line count
	;	0x06 token list

	;	[0x50, 0x100) general purpose

	; @ s[0x05] = 0
	ipush	0
	ilsave	0x05

	; @ s[0x06] = 0
	ipush	0
	ilsave	0x06

	; @ s[0x00] = inf_name
	iarg	1
	ilsave	0x00	
	
	; @ s[0x01] = fopen(s[0x00], "rb");	
	let		inf_readmode "rb"
	ipush	inf_readmode
	ilload	0x00
	ccall	fopen
	ilsave	0x01
	
	ilload	0x01
	jnz		B00_00
	let		err_fileopen "** FATAL ** couldn't open file '%s'"
	ilload	0x00
	ipush	err_fileopen
	ccall	println
	ccall	exit
B00_00:


	; @ s[0x02] contains contents of inf
	; @ fseek(s[0x01], SEEK_END, 0);
	ipush	0
	ipush	2
	ilload	0x01
	ccall	fseek
	; @ s[0x03] = ftell(s[0x01]);
	ilload	0x01
	ccall	ftell
	ilsave	0x03
	; @ fseek(s[0x01], SEEK_SET, 0);
	ipush	0
	ipush	1
	ilload	0x01
	ccall	fseek
	; @ s[0x02] = malloc(s[0x03]);
	ilload	0x03
	ccall	malloc
	ilsave	0x02
	; @ fread(s[0x01], s[0x02], s[0x03]);
	ilload	0x03
	ilload	0x02
	ilload	0x01
	ccall	fread
	; @ s[0x02][s[0x03]] = 0;
	ilload	0x02
	ilload	0x03
	iadd	
	ipush	0
	isave
B00:
	dboff
	; while (*s[0x02]);
	ilload	0x02
	cder
	jz		B01

	; s[0x04] = *s[0x02]
	ilload	0x02
	cder
	ilsave	0x04

	; if (s[0x04] == ' ' || s[0x04] == '\t') continue;
	ilload	0x04
	ipush	' '
	icmp
	ilload	0x04
	ipush	'\t'
	icmp
	lor
	jnz		Bcont

	; if (s[0x04] == '\n') s[0x05]++; continue;
	ilload	0x04
	ipush	'\n'
	icmp
	jz		B07
	ilload	0x05
	icinc	1
	ilsave	0x05
	jmp		Bcont
B07:
	; note store general purpose buffer at 0x50
	
	; if (s[0x04] == '\n') s[0x05]++; continue;
	ilload	0x04
	ipush	'\n'
	icmp	
	jz		B07_00
	
	; s[0x05]++;
	ilload	0x05
	icinc	1
	ilsave	0x05

	jmp		Bcont	
B07_00:
	; else if (isdigit(s[0x04])) goto B02;
	ilload	0x04
	call	isdigit, 1
	jnz		B02
	; else if (isalpha(s[0x04])) goto B03;
	ilload	0x04
	call	isalpha, 1
	jnz		B03
	; else if (ispunct(s[0x04])) goto B04;
	ilload	0x04
	call	ispunct, 1
	jnz		B04	
	jmp		Bcont
B02: ; is a number
	; be safe and allocate 64 bytes for a number
	; s[0x50] = malloc(64);
	ipush	64
	ccall	malloc
	ilsave	0x50
	; s[0x51] = s[0x50]; (this is the writing pointer)
	ilload	0x50
	ilsave	0x51
B02_00:
	; while (isdigit((s[0x04] = *s[0x02]++)));
	ilload	0x02
	cder	
	ilsave	0x04
	ilload	0x02
	icinc	1
	ilsave	0x02
	ilload	0x04
	call	isdigit, 1
	jz		B02_01

	; *s[0x51]++ = s[0x04]
	ilload	0x51
	ilload	0x04
	isave
	ilload	0x51
	icinc	1
	ilsave	0x51

	jmp		B02_00
B02_01:

	; *s[0x51] = '\0';
	ilload	0x51
	ipush	0
	isave
	
	; __Token_append(&s[0x06], TYPE_NUMBER (3), s[0x50]);
	ilload	0x50
	ipush	3
	ilea	0x06
	call	__Token_append, 3

	; s[0x02]--;
	ilload	0x02
	ipush	1
	isub
	ilsave	0x02
	
	jmp		Bcont
B03: ; is an identifier
	
	; we're going to scan ahead and find the end of the identifier
	; s[0x52] = length of identifier
	; s[0x53] = saved contents pointer
	ipush	0
	ilsave	0x52
	ilload	0x02
	ilsave	0x53

	; s[0x52]++
	ilload	0x52
	iadd	1
	ilsave	0x52

	; s[0x02]++
	ilload	0x02
	iadd	1
	ilsave	0x02

B03_00:
	; while isalnum(*s[0x02]++);
	ilload	0x02
	cder
	ilload	0x02
	icinc	1
	ilsave	0x02
	call	isalnum, 1
	jz		B03_01

	; s[0x52]++
	ilload	0x52
	icinc	1
	ilsave	0x52

	jmp		B03_00
B03_01:

	; restore the cotents ptr
	ilload	0x53
	ilsave	0x02

	; s[0x50] = malloc(s[0x52] + 1)
	ilload	0x52
	ipush	1
	iadd
	ccall	malloc
	ilsave	0x50
	; s[0x51] = s[0x50]
	ilload	0x50
	ilsave	0x51
	
	; s[0x54] = 0; (loop counter)
	ipush	0
	ilsave	0x54
B03_02:
	; loop again, this time copying to s[0x50]
	; while (s[0x54] < s[0x52]);
	ilload	0x54
	ilload	0x52
	ilt
	jz		B03_03

	; *s[0x51]++ = *s[0x02]++	
	ilload	0x51
	ilload	0x51
	icinc	1
	ilsave	0x51
	ilload	0x02
	cder
	ilload	0x02
	icinc	1
	ilsave	0x02 ; now stack is (s[0x51], *s[0x02])
	isave

	; s[0x54]++;
	ilload	0x54
	icinc	1
	ilsave	0x54

	jmp		B03_02
B03_03:

	; *[0x51] = '\0'
	ilload	0x51
	ipush	0
	isave

	; s[0x52] = TYPE_IDENTIFIER
	ipush	1
	ilsave	0x52
	
	; __Token_append(&s[0x06], TYPE_IDENTIFIER (1), s[0x50]);
	ilload	0x50
	ipush	kw_if
	call	strcmp, 2
	jz		B03_04
	ipush	44
	ilsave	0x52
	jmp		B03_done
B03_04:
	ilload	0x50
	ipush	kw_while
	call	strcmp, 2
	jz		B03_05
	ipush	45
	ilsave	0x52
	jmp		B03_done	
B03_05:
	ilload	0x50
	ipush	kw_for
	call	strcmp, 2
	jz		B03_06
	ipush	46
	ilsave	0x52
	jmp		B03_done	
B03_06:
	ilload	0x50
	ipush	kw_func
	call	strcmp, 2
	jz		B03_07
	ipush	47
	ilsave	0x52
	jmp		B03_done	
B03_07:
	ilload	0x50
	ipush	kw_do
	call	strcmp, 2
	jz		B03_08
	ipush	48
	ilsave	0x52
	jmp		B03_done	
B03_08:
	ilload	0x50
	ipush	kw_return
	call	strcmp, 2
	jz		B03_09
	ipush	49
	ilsave	0x52
	jmp		B03_done	
B03_09:
	ilload	0x50
	ipush	kw_continue
	call	strcmp, 2
	jz		B03_10
	ipush	50
	ilsave	0x52
	jmp		B03_done	
B03_10:
	ilload	0x50
	ipush	kw_break
	call	strcmp, 2
	jz		B03_done
	ipush	51
	ilsave	0x52
B03_done:

	ilload	0x50	
	ilload	0x52
	ilea	0x06
	call	__Token_append, 3

	jmp		Bcont
B04: ; ispunct
	; s[0x50] = malloc(3);
	ipush	2
	ccall	malloc
	ilsave	0x50

	ipush	0
	ilsave	0x52
	
	; push token type onto the stack
	ilload	0x04	
	ipush	'!'
	icmp	
	jz		B04_00
	ipush	4	
	jmp		B04_done	
B04_00:
	ilload	0x04
	ipush	'%'
	icmp
	jz		B04_01
	ipush	5
	jmp		B04_done
B04_01:
	ilload	0x04
	ipush	'&'
	icmp
	jz		B04_02
	ilload	0x02
	icinc	1
	cder
	ipush	'&'
	icmp
	jz		B04_01_00
	; is &&
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	7
	jmp		B04_done
B04_01_00:
	; is &
	ipush	6
	jmp		B04_done
B04_02:
	ilload	0x04
	ipush	'\''
	icmp
	jz		B04_03
	ipush	8
	jmp		B04_done
B04_03:
	ilload	0x04
	ipush	'('
	icmp
	jz		B04_04
	ipush	9
	jmp		B04_done
B04_04:
	ilload	0x04
	ipush	')'
	icmp
	jz		B04_05
	ipush	10
	jmp		B04_done
B04_05:
	ilload	0x04
	ipush	'*'
	icmp	
	jz		B04_06
	ilload	0x02
	icinc	1
	cder
	ipush	'='
	icmp
	jz		B04_05_00
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'='
	ilsave	0x52
	ipush	12 ; *=
	jmp		B04_done
B04_05_00:	
	ipush	11 ; *
	jmp		B04_done	
B04_06:
	ilload	0x04
	ipush	'+'
	icmp
	jz		B04_07
	ilload	0x02
	icinc	1
	cder
	ipush	'+'
	icmp
	jz		B04_06_00
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'+'
	ilsave	0x52
	ipush	14 ; ++
	jmp		B04_done
B04_06_00:
	ilload	0x02
	icinc	1
	cder
	ipush	'='
	icmp	
	jz		B04_06_01
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'='
	ilsave	0x52
	ipush	15 ; +=
	jmp		B04_done
B04_06_01:
	ipush	13 ; +
	jmp		B04_done
B04_07:	
	ilload	0x04
	ipush	','
	icmp
	jz		B04_08
	ipush	16
	jmp		B04_done
B04_08:
	ilload	0x04
	ipush	'-'
	icmp
	jz		B04_09
	ilload	0x02
	icinc	1
	cder
	ipush	'-'
	icmp
	jz		B04_08_00
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'-'
	ilsave	0x52
	ipush	18 ; --
	jmp		B04_done
B04_08_00:
	ilload	0x02
	icinc	1
	cder
	ipush	'='
	icmp
	jz		B04_08_01
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'='
	ilsave	0x52
	ipush	19 ; -=
	jmp		B04_done
B04_08_01:
	ilload	0x02
	icinc	1
	cder
	ipush	'>'
	icmp
	jz		B04_08_02
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'>'
	ilsave	0x52
	ipush	20 ; ->
	jmp		B04_done
B04_08_02:
	ipush	17
	jmp		B04_done
B04_09:
	ilload	0x04
	ipush	'.'
	icmp
	jz		B04_10
	ipush	21 ; .
	jmp		B04_done
B04_10:
	ilload	0x04
	ipush	'/'
	icmp
	jz		B04_11
	ilload	0x02
	icinc	1
	cder
	ipush	'/'
	icmp
	jz		B04_10_00
	ilload	0x02
	icinc
	ilsave	0x02
	ipush	23
	jmp		B04_done
B04_10_00:
	ipush	22
	jmp		B04_done
B04_11:
	ilload	0x04
	ipush	':'
	icmp
	jz		B04_12
	ilload	0x02
	icinc	1
	cder
	ipush	':'
	icmp
	jz		B04_11_00
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	':'
	ilsave	0x52
	ipush	25
	jmp		B04_done
B04_11_00:
	ipush	24
	jmp		B04_done
B04_12:
	ilload	0x04
	ipush	';'
	icmp
	jz		B04_13
	ipush	26
	jmp		B04_done
B04_13:
	ilload	0x04
	ipush	'<'
	icmp
	jz		B04_14
	ilload	0x02
	icinc	1
	cder
	ipush	'='
	icmp
	jz		B04_13_00
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'='
	ilsave	0x52
	ipush	28
	jmp		B04_done
B04_13_00:
	ilload	0x02
	icinc	1
	cder
	ipush	'<'
	icmp
	jz		B04_13_01
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'<'
	ilsave	0x52
	ipush	29
	jmp		B04_done
B04_13_01:
	ipush	27
	jmp		B04_done
B04_14:
	ilload	0x04
	ipush	'='
	icmp
	jz		B04_15
	ilload	0x02
	icinc	1
	cder
	ipush	'='
	icmp
	jz		B04_14_00
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'='
	ilsave	0x52
	ipush	31
	jmp		B04_done
B04_14_00:
	ipush	30
	jmp		B04_done
B04_15:
	ilload	0x04
	ipush	'>'
	icmp
	jz		B04_16
	ilload	0x02
	icinc	1
	cder
	ipush	'='
	icmp
	jz		B04_15_00
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'='
	ilsave	0x52
	ipush	33
	jmp		B04_done
B04_15_00:
	ilload	0x02
	icinc	1
	cder
	ipush	'>'
	icmp
	jz		B04_15_01
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'>'
	ilsave	0x52
	ipush	34
	jmp		B04_done
B04_15_01:
	ipush	32
	jmp		B04_done
B04_16:
	ilload	0x04
	ipush	'?'
	icmp
	jz		B04_17
	ipush	35
	jmp		B04_done
B04_17:
	ilload	0x04
	ipush	'['
	icmp
	jz		B04_18
	ipush	36
	jmp		B04_done
B04_18:
	ilload	0x04
	ipush	']'
	icmp
	jz		B04_19
	ipush	37
	jmp		B04_done
B04_19:
	ilload	0x04
	ipush	'^'
	icmp
	jz		B04_20
	ipush	38
	jmp		B04_done
B04_20:
	ilload	0x04
	ipush	'{'
	icmp
	jz		B04_21
	ipush	39
	jmp		B04_done
B04_21:
	ilload	0x04
	ipush	'|'
	icmp
	jz		B04_22
	ilload	0x02
	icinc	1
	cder
	jz		B04_22_00
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	'|'
	ilsave	0x52
	ipush	41
	jmp		B04_done
B04_22_00:
	ipush	40
	jmp		B04_done
B04_22:
	ilload	0x04
	ipush	'}'
	icmp
	jz		B04_23
	ipush	42
	jmp		B04_done
B04_23:
	ilload	0x04
	ipush	'~'
	icmp
	jz		B04_24
	ipush	43
	jmp		B04_done
B04_24:
	ipush	0
B04_done:
	ilsave	0x51

	; s[0x50][0] = s[0x04]
	ilload	0x50
	ilload	0x04
	isave

	;s[0x50][1] = s[0x52]
	ilload	0x50
	icinc	1
	ilload	0x52
	isave

	; s[0x50][2] = 0;
	ilload	0x50
	icinc	2
	ipush	0
	isave

	ilload	0x50
	ilload	0x51
	ilea	0x06
	call	__Token_append, 3

	jmp		Bcont
B05:
B06:

Bcont: ; continue label

	; s[0x02]++;
	ilload	0x02
	icinc	1
	ilsave	0x02	
	jmp		B00
B01:
	ilload	0x06
	call	__Token_print, 1


	; ----------------------------------------- DONE LEXING, START PARSING --------------------------------------------


	ipush	0
