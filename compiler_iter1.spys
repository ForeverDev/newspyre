; C functions that are needed
let print		"print"
let println		"println"

let malloc		"malloc"
let free		"free"
let exit		"exit"

let fopen		"fopen"
let fclose		"fclose"
let fputc		"fputc"
let fputs		"fputs"
let fseek		"fseek"
let ftell		"ftell"
let fread		"fread"
let fgetc		"fgetc"

; constant strings
let format_char	"%c"
let format_int	"%d"
let format_hex	"%x"
let format_ptr	"%p"
let format_str	"%s"
let newline		"\n"
let tab			"\t"
let nullchar	"\0"

jmp main

; args
; 0 -> pointer to string
strlen:
	iarg	0 ; string (0x00)
	ipush	0 ; length (0x01)
A00:
	; *string == 0
	ilload	0x00
	cder
	ipush	0
	icmp
	jnz		A01
	
	; string++
	ilload	0x00
	icinc	1
	ilsave	0x00
	
	; length++
	ilload	0x01
	icinc	1
	ilsave	0x01

	jmp		A00
A01:
	; return length
	ilload	0x01
	iret

; args
;	0 -> destination
;	1 -> source
strcpy:
	iarg	0 ; s[0x00] = destination
	iarg	1 ; s[0x01] = source
Z00:
	; while (*s[0x01]);
	ilload	0x01
	cder
	jz		Z01
	
	; *s[0x01]+ = *s[0x00]+
	ilload	0x00
	ilload	0x01
	cder
	isave

	ilload	0x00
	icinc	1
	ilsave	0x00

	ilload	0x01
	icinc	1
	ilsave	0x01

	jmp		Z00
Z01:
	vret

; args
;	0 -> char n
isdigit:
	iarg	0
	ipush	'0'
	ige
	iarg	0
	ipush	'9'
	ile
	land
	iret

; args
;	0 -> char n
isalpha:
	iarg	0
	ipush	'a'
	ige
	iarg	0
	ipush	'z'
	ile
	land
	iarg	0
	ipush	'A'
	ige
	iarg	0
	ipush	'Z'
	ile
	land
	lor
	iret

; args
;	0 -> char n
isalnum:
	iarg	0
	call	isalpha, 1
	iarg	0
	call	isdigit, 1
	lor
	iret

; args
;	0 -> char n
ispunct:
	; return (
	;	(n >= '!' && n <= '/') ||
	;	(n >= ':' && n <= '@') ||
	;	(n >= '[' && n <= '\'') ||
	;	(n >= '{' && n <= '~')
	; );
	iarg	0
	ilload	'!'
	ige
	iarg	0
	ilload	'/'
	ile
	land
	iarg	0
	ilload	':'
	ige
	iarg	0
	ilload '@'
	ile
	land
	lor
	iarg	0
	ilload	'['
	ige
	iarg	0
	ilload	'\''
	ile
	land
	lor
	iarg	0
	ilload	'{'
	ige
	iarg	0
	ilload	'~'
	ile
	land
	lor
	ilsave	0x00
	iret


; token format
;	0 -> type
;	1 -> word
;	2 -> next

; args
;	0 -> type
;	1 -> word
__Token_new:
	ipush	0 ; 0x00 -> token storage

	; token = malloc(24);
	ipush	24
	ccall	malloc
	ilsave	0x00
	
	; token->type = args[0x00]
	ilload	0x00
	ipush	0
	padd
	iarg	0
	isave

	; token->word = malloc(strlen(args[1]) + 1);
	ilload	0x00
	ipush	1
	padd
	iarg	1
	call	strlen, 1
	ipush	1
	iadd
	ccall	malloc
	isave

	; strcpy(token->word, args[1]);
	iarg	1
	ilload	0x00
	ipush	1
	padd
	ider
	call	strcpy, 2
	
	; token->next = NULL;
	ilload	0x00
	ipush	2
	padd	
	ipush	0
	isave

	; return token;
	ilload	0x00
	iret

; args
;	0 -> Token**	head
;	1 -> int		type
;	2 -> char*		word

__Token_append:
	res		3

	; s[0x00] = arg0 (token)
	iarg	0
	ilsave	0x00

	; s[0x01] = __Token_new(arg[1], arg[2]);
	iarg	2
	iarg	1
	call	__Token_new, 2
	ilsave	0x01

	; s[0x02] = *token
	iarg	0
	ider
	ilsave	0x02
	
	ilload	0x02	
	jz		C01
C00: ; *head != NULL
C00_00:
	; while ((*token)->next);
	ilload	0x02
	ipush	2
	padd
	ider
	jz		C00_01
	
	; (*token) = (*token)->next;	
	ilload	0x02
	ilload	0x02
	ipush	2
	padd
	ider
	ilsave	0x02

	jmp		C00_00
C00_01:
	; (*token)->next = s[0x01]
	ilload	0x02
	ipush	2
	padd	
	ilload	0x01
	isave

	jmp		C02
C01: ; *head == NULL
	; *head = s[0x00]	
	ilload	0x00
	ilload	0x01
	isave
C02:
	vret

__Token_print:
	iarg	0
D00:
	ilload	0x00
	jz		D01

	ilload	0x00
	ipush	1
	padd
	ider
	ipush	format_str
	ccall	println

	ilload	0x00
	ipush	2
	padd
	ider
	ilsave	0x00

	jmp		D00
D01:
	vret	

; args:
;	0 -> nargs (can ignore)
;	1 -> input file name
main:
	res		0x100

	; stack map
	;	0x00 input file name
	;	0x01 input file handle
	;	0x02 input file contents
	;	0x03 input file contents length
	;	0x04 current character
	;	0x05 line count
	;	0x06 token list

	;	[0x50, 0x100) general purpose

	; @ s[0x05] = 0
	ipush	0
	ilsave	0x05

	; @ s[0x06] = 0
	ipush	0
	ilsave	0x06

	; @ s[0x00] = inf_name
	iarg	1
	ilsave	0x00	
	
	; @ s[0x01] = fopen(s[0x00], "rb");	
	let		inf_readmode "rb"
	ipush	inf_readmode
	ilload	0x00
	ccall	fopen
	ilsave	0x01
	
	ilload	0x01
	jnz		B00_00
	let		err_fileopen "** FATAL ** couldn't open file '%s'"
	ilload	0x00
	ipush	err_fileopen
	ccall	println
	ccall	exit
B00_00:


	; @ s[0x02] contains contents of inf
	; @ fseek(s[0x01], SEEK_END, 0);
	ipush	0
	ipush	2
	ilload	0x01
	ccall	fseek
	; @ s[0x03] = ftell(s[0x01]);
	ilload	0x01
	ccall	ftell
	ilsave	0x03
	; @ fseek(s[0x01], SEEK_SET, 0);
	ipush	0
	ipush	1
	ilload	0x01
	ccall	fseek
	; @ s[0x02] = malloc(s[0x03]);
	ilload	0x03
	ccall	malloc
	ilsave	0x02
	; @ fread(s[0x01], s[0x02], s[0x03]);
	ilload	0x03
	ilload	0x02
	ilload	0x01
	ccall	fread
	; @ s[0x02][s[0x03]] = 0;
	ilload	0x02
	ilload	0x03
	iadd	
	ipush	0
	isave
B00:
	; while (*s[0x02]);
	ilload	0x02
	cder
	jz		B01

	; s[0x04] = *s[0x02]
	ilload	0x02
	cder
	ilsave	0x04

	; if (s[0x04] == ' ' || s[0x04] == '\t') continue;
	ilload	0x04
	ipush	' '
	icmp
	ilload	0x04
	ipush	'\t'
	icmp
	lor
	jnz		Bcont

	; if (s[0x04] == '\n') s[0x05]++; continue;
	ilload	0x04
	ipush	'\n'
	icmp
	jz		B07
	ilload	0x05
	icinc	1
	ilsave	0x05
	jmp		Bcont
B07:

	; note store general purpose buffer at 0x50
	
	; if (s[0x04] == '\n') s[0x05]++; continue;
	ilload	0x04
	ipush	'\n'
	icmp	
	jz		B07_00
	
	; s[0x05]++;
	ilload	0x05
	icinc	1
	ilsave	0x05

	jmp		Bcont	
B07_00:

	; else if (isdigit(s[0x04])) goto B02;
	ilload	0x04
	call	isdigit, 1
	jnz		B02
	; else if (isalpha(s[0x04])) goto B03;
	ilload	0x04
	call	isalpha, 1
	jnz		B03
	; else if (ispunct(s[0x04])) goto B04;
	ilload	0x04
	call	ispunct, 1
	jnz		B04	
	jmp		Bcont
B02: ; is a number
	; be safe and allocate 64 bytes for a number
	; s[0x50] = malloc(64);
	ipush	64
	ccall	malloc
	ilsave	0x50
	; s[0x51] = s[0x50]; (this is the writing pointer)
	ilload	0x50
	ilsave	0x51
B02_00:
	; while (isdigit((s[0x04] = *s[0x02]++)));
	ilload	0x02
	cder	
	ilsave	0x04
	ilload	0x02
	icinc	1
	ilsave	0x02
	ilload	0x04
	call	isdigit, 1
	jz		B02_01

	; *s[0x51]++ = s[0x04]
	ilload	0x51
	ilload	0x04
	isave
	ilload	0x51
	icinc	1
	ilsave	0x51

	jmp		B02_00
B02_01:

	; *s[0x51] = '\0';
	ilload	0x51
	ipush	0
	isave
	
	; __Token_append(&s[0x06], TYPE_NUMBER (3), s[0x50]);
	ilload	0x50
	ipush	3
	ilea	0x06
	call	__Token_append, 3

	; s[0x02]--;
	ilload	0x02
	ipush	1
	isub
	ilsave	0x02
	
	jmp		Bcont
B03: ; is an identifier
	
	; we're going to scan ahead and find the end of the identifier
	; s[0x52] = length of identifier
	; s[0x53] = saved contents pointer
	ipush	0
	ilsave	0x52
	ilload	0x02
	ilsave	0x53

	; s[0x52]++
	ilload	0x52
	iadd	1
	ilsave	0x52

	; s[0x02]++
	ilload	0x02
	iadd	1
	ilsave	0x02

B03_00:
	; while isalnum(*s[0x02]++);
	ilload	0x02
	cder
	ilload	0x02
	icinc	1
	ilsave	0x02
	call	isalnum, 1
	jz		B03_01

	; s[0x52]++
	ilload	0x52
	icinc	1
	ilsave	0x52

	jmp		B03_00
B03_01:

	; restore the cotents ptr
	ilload	0x53
	ilsave	0x02

	; s[0x50] = malloc(s[0x52] + 1)
	ilload	0x52
	ipush	1
	iadd
	ccall	malloc
	ilsave	0x50
	; s[0x51] = s[0x50]
	ilload	0x50
	ilsave	0x51
	
	; s[0x54] = 0; (loop counter)
	ipush	0
	ilsave	0x54
B03_02:
	; loop again, this time copying to s[0x50]
	; while (s[0x54] < s[0x52]);
	ilload	0x54
	ilload	0x52
	ilt
	jz		B03_03

	; *s[0x51]++ = *s[0x02]++	
	ilload	0x51
	ilload	0x51
	icinc	1
	ilsave	0x51
	ilload	0x02
	cder
	ilload	0x02
	icinc	1
	ilsave	0x02 ; now stack is (s[0x51], *s[0x02])
	isave

	; s[0x54]++;
	ilload	0x54
	icinc	1
	ilsave	0x54

	jmp		B03_02
B03_03:

	; *[0x51] = '\0'
	ilload	0x51
	ipush	0
	isave
	
	; __Token_append(&s[0x06], TYPE_IDENTIFIER (1), s[0x50]);
	ilload	0x50	
	ipush	1
	ilea	0x06
	call	__Token_append, 3

	jmp		Bcont
B04: ; ispunct
	; s[0x50] = malloc(2);
	ipush	2
	ccall	malloc
	ilsave	0x50
	
	; push token type onto the stack
	ilload	0x04	
	ipush	'!'
	icmp	
	jz		B04_00
	ipush	4	
	jmp		B04_done	
B04_00:
	ilload	0x04
	ipush	'%'
	icmp
	jz		B04_01
	ipush	5
	jmp		B04_done
B04_01:
	ilload	0x04
	ipush	'&'
	icmp
	jz		B04_02
	ilload	0x02
	icinc	1
	cder
	ipush	'&'
	icmp
	jz		B04_01_00
	; is &&
	ilload	0x02
	icinc	1
	ilsave	0x02
	ipush	7
	jmp		B04_done
B04_01_00:
	; is &
	ipush	6
	jmp		B04_done
B04_02:
	ipush	0
B04_done:
	ilsave	0x51
	ilload	0x51
	ipush	format_int
	ccall	println
	jmp		Bcont
B05:
B06:

Bcont: ; continue label

	; s[0x02]++;
	ilload	0x02
	icinc	1
	ilsave	0x02	
	jmp		B00
B01:
	ipush	0
